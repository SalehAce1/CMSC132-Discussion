

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>11/17 Exam 3 Review &mdash; CMSC132-Discussion 2021 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/dark_mode_css/general.css" type="text/css" />
  <link rel="stylesheet" href="_static/dark_mode_css/dark.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/dark_mode_js/default_dark.js"></script>
        <script src="_static/dark_mode_js/theme_switcher.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="11/15 LL/Hashing Wks" href="Nov-15.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> CMSC132-Discussion
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Sep-1.html">9/1 Intro/Using Eclipse</a></li>
<li class="toctree-l1"><a class="reference internal" href="Sep-8.html">9/8 Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="Sep-13.html">9/13 Memory Maps and Quiz</a></li>
<li class="toctree-l1"><a class="reference internal" href="Sep-15.html">9/15 JUnit Tests and Inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="Sep-20.html">9/20 Inheritance/Exceptions/Comparators</a></li>
<li class="toctree-l1"><a class="reference internal" href="Sep-22.html">9/22 Exam Review</a></li>
<li class="toctree-l1"><a class="reference internal" href="Sep-27.html">9/27 Singletons and Decorators</a></li>
<li class="toctree-l1"><a class="reference internal" href="Sep-29.html">9/29 StringBuffer and Command Line</a></li>
<li class="toctree-l1"><a class="reference internal" href="Oct-11.html">10/12 UML</a></li>
<li class="toctree-l1"><a class="reference internal" href="Oct-13.html">10/13 UML Continued</a></li>
<li class="toctree-l1"><a class="reference internal" href="Oct-18.html">10/18 Linked Lists</a></li>
<li class="toctree-l1"><a class="reference internal" href="Oct-20.html">10/20 Exam Review</a></li>
<li class="toctree-l1"><a class="reference internal" href="Oct-25.html">10/25 Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="Oct-27.html">10/27 Maps Worksheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="Nov-1.html">11/1 Quiz 3 Practice</a></li>
<li class="toctree-l1"><a class="reference internal" href="Nov-8.html">11/8 Polymorphic Lists</a></li>
<li class="toctree-l1"><a class="reference internal" href="Nov-10.html">11/10 Sorted Polymorphic Lists</a></li>
<li class="toctree-l1"><a class="reference internal" href="Nov-15.html">11/15 LL/Hashing Wks</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11/17 Exam 3 Review</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#reminders">Reminders</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exam-logistics">Exam Logistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exam-review">Exam Review</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#recursion">Recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-maps">Memory Maps</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linear-data-structures">Linear Data Structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hashing">Hashing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sets-maps">Sets/Maps</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CMSC132-Discussion</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>11/17 Exam 3 Review</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/Nov-17.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="exam-3-review">
<h1>11/17 Exam 3 Review<a class="headerlink" href="#exam-3-review" title="Permalink to this headline">¶</a></h1>
<div class="section" id="reminders">
<h2>Reminders<a class="headerlink" href="#reminders" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p>Third Exam is on Friday 11/16.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="exam-logistics">
<h2>Exam Logistics<a class="headerlink" href="#exam-logistics" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p>Find Exam info page <a class="reference external" href="https://www.cs.umd.edu/class/fall2021/cmsc132-030X/exams/exam3/">here.</a></p></li>
<li><p>Also look at Piazza post &#64;288 for the general format.</p></li>
<li><p>There will be an online study session held by some of the TAs on Wednesday</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="exam-review">
<h2>Exam Review<a class="headerlink" href="#exam-review" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Revisit 10/21 and 9/23 discussion notes to look over concepts from prior exams</p></li>
</ul>
<div class="section" id="recursion">
<h3>Recursion<a class="headerlink" href="#recursion" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Recursion is an approach to solve a problem by creating a method that has a call to itself within the body of the method.</p></li>
<li><p><strong>All</strong> iterative solutions can be rewritten as recursive solutions because iteration is simply a special case of recursion: <strong>tail recursion</strong>.</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Tail recursion</strong> occurs when the method has a recursive call as its final action and no additional processing.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example of a tail recursive method</span>
<span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partialResult</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">partialResult</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">partialResult</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Written iteratively</span>
<span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partialResult</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">partialResult</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">partialResult</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">partialResult</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="memory-maps">
<h3>Memory Maps<a class="headerlink" href="#memory-maps" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>These maps have a space for the stack and a space for the heap.</p></li>
<li><p>We can look at some examples.</p></li>
</ul>
</div>
<div class="section" id="linear-data-structures">
<h3>Linear Data Structures<a class="headerlink" href="#linear-data-structures" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>These data structures include Linked Lists, Stacks, Queues, etc.</p></li>
<li><p>Let’s look at the slideset to review <a class="reference external" href="https://www.cs.umd.edu/class/fall2021/cmsc132-030X/lectures/Week6/LinearDataStructures.pdf">Linked Lists</a></p></li>
<li><p>You want to know how to make iterative and recursive methods for Linked Lists.</p></li>
<li><p>Iterative solutions will use references to previous/current Node(s) to move through the Linked List.</p></li>
</ul>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="c1">// Suppose you only need to modify one element</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodX</span><span class="p">(</span><span class="n">T</span> <span class="n">targetData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">curr</span><span class="p">.</span><span class="na">data</span> <span class="o">!=</span> <span class="n">targetData</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="p">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Process node here</span>
<span class="p">}</span>

<span class="c1">// Suppose you want to delete an element. In that case, you need to also keep track of the previous Node.</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodY</span><span class="p">(</span><span class="n">T</span> <span class="n">targetData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">Node</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">curr</span><span class="p">.</span><span class="na">data</span> <span class="o">!=</span> <span class="n">targetData</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="p">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Process node here</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Recursive solutions will often times utilize auxiliary methods that take in an additional parameter representing the head of the current section of the Linked List.</p></li>
</ul>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodZ</span><span class="p">(</span><span class="n">T</span> <span class="n">targetData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">methodZAux</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">targetData</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">methodZAux</span><span class="p">(</span><span class="n">Node</span> <span class="n">headAux</span><span class="p">,</span> <span class="n">T</span> <span class="n">targetData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">headAux</span><span class="p">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">targetData</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Process node here</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">methodZAux</span><span class="p">(</span><span class="n">headAux</span><span class="p">.</span><span class="na">next</span><span class="p">,</span> <span class="n">targetData</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul>
<li><p>Some tips for writing recursive solutions for Linked Lists:</p>
<blockquote>
<div><ul class="simple">
<li><p>Be deliberate about what your return types are, these can make the solution easier.</p></li>
<li><p>Keep track of what the possible base cases are. <strong>MAKE SURE THERE IS NO INFINITE RECURSION</strong>.</p></li>
<li><p>Begin writing your solution as if the recursive method already performs the correct work. This can simplify the thought process and make it clear what code needs to be written.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Another TA, <strong>Matthew Simmons</strong>, was kind enough to make a bunch of examples to get us comfortable with Java’s Abstract Data Types!</p>
<blockquote>
<div><ul>
<li><p>Stack Questions:</p>
<blockquote>
<div><p>Say we want to reverse a Stack (and don’t care about modifying the original). It can be done like so:</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">newStack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stack</span><span class="p">.</span><span class="na">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">newStack</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="na">pop</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">newStack</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, what if we wish to preserve the original?
Double the Stack, then reverse one of them (with modifying)!</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">newStack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">tempStack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stack</span><span class="p">.</span><span class="na">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">value</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="na">pop</span><span class="p">();</span>
        <span class="n">newStack</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="n">tempStack</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">tempStack</span><span class="p">.</span><span class="na">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">stack</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="n">tempStack</span><span class="p">.</span><span class="na">pop</span><span class="p">());</span> <span class="c1">// Reverse the reversed - back to normal!</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">newStack</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, what if we want the size?
Similar!</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="p">(</span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">tempStack</span> <span class="o">=</span> <span class="n">reverse</span><span class="p">(</span><span class="n">reverse</span><span class="p">(</span><span class="n">stack</span><span class="p">));</span> <span class="c1">// Fancy way to make a copy :)</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">tempStack</span><span class="p">.</span><span class="na">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">tempStack</span><span class="p">.</span><span class="na">pop</span><span class="p">();</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
<hr class="docutils" />
<blockquote>
<div><ul>
<li><p>Queue Questions:</p>
<blockquote>
<div><p>Let’s try to get the size of a queue (pretend there’s no size() method already)
Idea: poll() until there’s nothing left will give count - also ensure we don’t modify queue!</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="p">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">tempQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// Queue is an interface so we can&#39;t instantiate it - but an ArrayList is-a Queue!</span>
    <span class="k">while</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="na">peek</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tempQueue</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="na">poll</span><span class="p">());</span> <span class="c1">// Adds in order - FIFO still - tempQueue will be old queue!</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">tempQueue</span><span class="p">;</span> <span class="c1">// Queue keeps its elements in order!</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Reversing is still cool - can we do that?
Looks weird, but sure! We must add beginning with the last element, then work backwards (sounds like recursion to me!)</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">newQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="n">reverseAux</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">newQueue</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">newQueue</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">reverseAux</span><span class="p">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">oldQueue</span><span class="p">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">reversedQueue</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">oldQueue</span><span class="p">.</span><span class="na">peek</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">value</span> <span class="o">=</span> <span class="n">oldQueue</span><span class="p">.</span><span class="na">poll</span><span class="p">();</span>
        <span class="n">reverseAux</span><span class="p">(</span><span class="n">oldQueue</span><span class="p">,</span> <span class="n">reversedQueue</span><span class="p">);</span> <span class="c1">// Same call as before - is this an infinite loop?</span>
        <span class="n">reversedQueue</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, to do this without modifying the original (exercise for you - you’ll need two helpers instead of two whiles in the Stack example)</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><ul>
<li><p>How about Deques? (Pronounced Decks - I don’t know why)</p>
<blockquote>
<div><p>Deques are a combination of a Stack and a Queue - so implementations as above work (changing method names) for size and reverse!
If Queue is like a linked list, Deque is like a doubly-linked list! (next and prev Node)
Makes things nice when you need both ends
Ex: Swap the first and last values of a Queue, Stack, and Deque.
Queue: Very sad iterations :( Same with Stack
But Deque:</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">swapFirstLast</span><span class="p">(</span><span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">deque</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Assume big enough to do this</span>
    <span class="n">T</span> <span class="n">first</span> <span class="o">=</span> <span class="n">deque</span><span class="p">.</span><span class="na">pollFirst</span><span class="p">();</span>
    <span class="n">T</span> <span class="n">last</span> <span class="o">=</span> <span class="n">deque</span><span class="p">.</span><span class="na">pollLast</span><span class="p">();</span>

    <span class="n">deque</span><span class="p">.</span><span class="na">addFirst</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
    <span class="n">deque</span><span class="p">.</span><span class="na">addLast</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Exercise: This can cause issues if there are too few elements. Fix it up!
Here’s something a little more deque-sized:
Given a Deque, re-order it so we alternate 1, n, 2, n-1, …
Ex: 1, 2, 3, 4, 5 -&gt; 1, 5, 2, 4, 3</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="c1">// Recursion</span>
<span class="kd">public</span> <span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">reorder</span><span class="p">(</span><span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">deque</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">newDeque</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;</span><span class="p">();</span> <span class="c1">// LinkedList implements Deque</span>
    <span class="n">reorderAux</span><span class="p">(</span><span class="n">deque</span><span class="p">,</span> <span class="n">newDeque</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">newDeque</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Idea: Boolean will alternate each call for if we poll from front or back!</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">reorderAux</span><span class="p">(</span><span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">oldDeque</span><span class="p">,</span> <span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">newDeque</span><span class="p">,</span> <span class="kt">boolean</span> <span class="n">fromFront</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">oldDeque</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fromFront</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">newDeque</span><span class="p">.</span><span class="na">addLast</span><span class="p">(</span><span class="n">oldDeque</span><span class="p">.</span><span class="na">pollFirst</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">newDeque</span><span class="p">.</span><span class="na">addLast</span><span class="p">(</span><span class="n">oldDeque</span><span class="p">.</span><span class="na">pollLast</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="n">reorderAux</span><span class="p">(</span><span class="n">oldDeque</span><span class="p">,</span> <span class="n">newDeque</span><span class="p">,</span> <span class="o">!</span><span class="n">fromFront</span><span class="p">);</span> <span class="c1">// Remember, oldDeque is already changed since pollFirst() /</span>
                                                    <span class="c1">// pollLast() removes one!</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="c1">// Iteration</span>
<span class="kd">public</span> <span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">reorder</span><span class="p">(</span><span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">oldDeque</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">newDeque</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="kt">boolean</span> <span class="n">fromFront</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">oldDeque</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fromFront</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">newDeque</span><span class="p">.</span><span class="na">addLast</span><span class="p">(</span><span class="n">oldDeque</span><span class="p">.</span><span class="na">pollFirst</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">newDeque</span><span class="p">.</span><span class="na">addLast</span><span class="p">(</span><span class="n">oldDeque</span><span class="p">.</span><span class="na">pollFirst</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="n">fromFront</span> <span class="o">=</span> <span class="o">!</span><span class="n">fromFront</span><span class="p">;</span> <span class="c1">// Flips direction each time</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">newDeque</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="hashing">
<h3>Hashing<a class="headerlink" href="#hashing" title="Permalink to this headline">¶</a></h3>
<p>Collision Handling:</p>
<ul>
<li><p><strong>Open Addressing</strong>: Look for another open spot on the table.</p>
<blockquote>
<div><ul class="simple">
<li><p>Linear probing: Place the value into the next open spot.</p></li>
<li><p>Quadratic probing: If at index k = j, go to index k + j^2, this prevents clustering.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Separate Chaining</strong>: Each element can store multiple values.</p></li>
<li><p><strong>Java’s Hash Code Contract</strong>: <code class="code docutils literal notranslate"><span class="pre">a.equals(b)</span> <span class="pre">=&gt;</span> <span class="pre">a.hashCode()</span> <span class="pre">==</span> <span class="pre">b.hashCode()</span></code> but the inverse and converse are not true.</p></li>
<li><p><strong>Load factor</strong>: = number of elements / table capacity (size of array) =&gt; tells us how full the table is.</p></li>
<li><p><a class="reference external" href="https://www.cs.umd.edu/class/fall2021/cmsc132-030X/lectures/Week8/Hashing.pdf">Link to hashing just to be safe</a></p></li>
<li><p>Now we’ll go through a more detailed example of handling collisions, created by another TA, <strong>Matthew Simmons</strong>:</p>
<blockquote>
<div><ul>
<li><p>Seperate Chaining:</p>
<blockquote>
<div><p>Slap a linked list into it! Our data structure will look like this:
LinkedList&lt;T&gt;[] table = new LinkedList&lt;T&gt;[capacity]; // An array of linked lists!
Instead of the hash index referring to the value, it points to a list with the value in it.
Now, just iterate through this list!
Example:</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hashIndex</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="c1">// hashIndex is a method in HashTable - does as described above.</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Do nothing if value is already in list - is this &quot;necessary&quot;?</span>
        <span class="n">table</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Where this method calls LinkedList.add(), which is what you implemented in your project (addToFront / addToEnd - doesn’t matter which).
Delete() and search() are similarly short.
Pros:</p>
<ul class="simple">
<li><p>Shorter code!</p></li>
<li><p>No “need” to resize the table! (It would still be good to)</p></li>
</ul>
<p>Cons:</p>
<ul class="simple">
<li><p>Slower Big-O (If everything is in one linkedlist, search is still O(n), not O(1))</p></li>
<li><p>Need to use Linked Lists</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Open Addressing:</p>
<blockquote>
<div><p>In this case, we instead try inserting in a new spot!</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="o">[</span><span class="n">capacity</span><span class="o">]</span><span class="p">;</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hashIndex</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">nextOpenIndex</span> <span class="o">=</span> <span class="n">nextOpen</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
    <span class="n">table</span><span class="o">[</span><span class="n">nextOpenIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, search() and delete() are similarly short - see lecture for algorithms.
However, how do we deal with collisions?
The “easiest” method to do such a thing is called linear probing - we keep checking to the right for open spots.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kt">int</span> <span class="nf">nextOpen</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">table</span><span class="o">[</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">capacity</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// index + i % size - goes from index, index + 1, ... size - 1, 0, 1, ... index - 1.</span>
            <span class="k">return</span> <span class="n">index</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// If we get here, there&#39;s no open spots - need to fix that!</span>
    <span class="n">resize</span><span class="p">();</span> <span class="c1">// Worst-case scenario to resize - it would be better to do this earlier (depending on load factor!)</span>
    <span class="k">return</span> <span class="n">nextOpen</span><span class="p">(</span><span class="n">index</span><span class="p">);</span> <span class="c1">// Now we can finally</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we simply keep checking each spot until we reach a new spot!
What if there’s no openings? We must increase the size!
The most common way to do this is to just double the size, then put the value back in.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">resize</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">T</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
    <span class="n">T</span><span class="o">[]</span> <span class="n">newTable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="o">[</span><span class="n">capcity</span> <span class="o">*</span> <span class="mi">2</span><span class="o">]</span><span class="p">;</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">newTable</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">oldSize</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="n">capacity</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oldSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// We must put the values in the new hash!</span>
        <span class="n">insert</span><span class="p">(</span><span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span> <span class="c1">// Gets each old value and re-adds it with the new hash index.</span>
    <span class="p">}</span>  <span class="c1">// NOTE: capacity and table are both updated, that is why insert() works.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Pros:</p>
<ul class="simple">
<li><p>Fast!</p></li>
<li><p>No linked lists!</p></li>
</ul>
<p>Cons:</p>
<ul class="simple">
<li><p>Resizing is yucky</p></li>
<li><p>Dealing with collisions is lame</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="sets-maps">
<h3>Sets/Maps<a class="headerlink" href="#sets-maps" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p><strong>Sets</strong>:</p>
<blockquote>
<div><ul>
<li><p>Sets are collections of elements without duplicates.</p></li>
<li><p>They do not have ordering. The order in which elements are added does not matter either.</p></li>
<li><p>Sets offer the ability to quickly find and remove elements quickly. (Ideally does not require searching through all the elements)</p></li>
<li><p>Concrete Sets Classes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">HashSet</span></code>, where elements must implement the <code class="code docutils literal notranslate"><span class="pre">hashCode()</span></code> method.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">LinkedHashSet</span></code>, which is a <code class="code docutils literal notranslate"><span class="pre">HashSet</span></code> supporting the insertion order of elements.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">TreeSet</span></code>, which requires elements to be <code class="code docutils literal notranslate"><span class="pre">Comparable</span></code> or provide a <code class="code docutils literal notranslate"><span class="pre">Comparator</span></code>. This data structure ensures the elements are in sorted order.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Maps</strong>:</p>
<blockquote>
<div><ul>
<li><p>Maps are an unordered collection of keys, and each key has an associated value.</p></li>
<li><p>The keys are used to retrieve the associated values.</p></li>
<li><p>You can think of Maps as arrays that are indexed by any key instead of incrementing integers.</p></li>
<li><p>Concrete Maps Classes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">HashMap</span></code>, where elements must implement the <code class="code docutils literal notranslate"><span class="pre">hashCode()</span></code> method.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">LinkedHashMap</span></code>, which is a <code class="code docutils literal notranslate"><span class="pre">HashSet</span></code> supporting the insertion order of elements.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">TreeMap</span></code>, which requires elements to be <code class="code docutils literal notranslate"><span class="pre">Comparable</span></code> or provide a <code class="code docutils literal notranslate"><span class="pre">Comparator</span></code>. This data structure ensures the elements are in sorted order.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Methods you should know:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">put(K</span> <span class="pre">key,</span> <span class="pre">V</span> <span class="pre">val)</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">V</span> <span class="pre">get(Object</span> <span class="pre">key)</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">int</span> <span class="pre">size()</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">boolean</span> <span class="pre">containsKey(Object</span> <span class="pre">key)</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">boolean</span> <span class="pre">containsValue(Object</span> <span class="pre">val)</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Set&lt;K&gt;</span> <span class="pre">keySet()</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Collection&lt;V&gt;</span> <span class="pre">values()</span></code></p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Nov-15.html" class="btn btn-neutral float-left" title="11/15 LL/Hashing Wks" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Seyed Mohammad Ghaemi and Abhay Patel.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>